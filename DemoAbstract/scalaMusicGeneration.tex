
\documentclass[preprint]{sigplanconf}

\usepackage{amsmath}
\usepackage{listings}
% "define" Scala for lstlisting
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,
    do,else,extends,false,final,finally,
    for,if,implicit,import,match,mixin,
    new,null,object,override,package,
    private,protected,requires,return,sealed,
    super,this,throw,trait,true,try,
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]'',
  morestring=[b]',
  morestring=[b]"",
}



\begin{document}

\newcommand{\lln}[1]{
  \lstinline@#1@
}
\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{20yy} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

%\titlebanner{}                   % These are ignored unless
\preprintfooter{Scala music generation - work in progress}   % 'preprint' option specified.

\title{Scala music generation}
%\subtitle{Subtitle Text, if any}

\authorinfo{Val\'erian Pittet \
           %\and Nada Amin \and Viktor Kuncak\
           }
           {Swiss Federal Institute of Technology in Lausanne}
           {valerian.pittet@epfl.ch\
           %, nada.amin@epfl.ch, viktor.kuncak@epfl.ch
           }

\maketitle

\begin{abstract}
% TODO Check which part will stand in introduction and which part will stand in abstract


The Scala programming language provides powerful tools to describe domain specific language and is thus a good candidate to implement functional music generation along with a DSL.

The work described in this presentation aim to develop structures to represent musical components, a DSL to describe them and high-order tools used to generate more complex melodies.

The first part will focus on design choices that has been done regarding music representation as a domain specific language with their implementation and uses for music generation. The second part will present the different approaches to implement higher concepts for music generation.

\end{abstract}

% copyright data
%\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
% \terms
% term1, term2

\keywords
Scala, DSL, Music generation

\section{Introduction}

When it comes to implement a music generation program, the first need that arises is to have a good structure to represent and play melodies. This can be done as a domain specific language, implementing both data representation and manipulation through dedicated operators.
Hence, the first part of the project was to implement a good DSL to describe music, providing lightweight and readable melody definition as well as efficient tools to manipulate and transform melodies.
The DSL has been developed keeping in mind those two main objectives. This may lead to some non-conventional definitions and even sometimes overcomplicated implementations that may need reviewing and refactoring.

Then this DSL support will be used to build higher order methods and ideally formal grammar concept to provide music generation capabilities.

Let's have a look at the current progress of that project.



\section{Low-level melody description}

When referring to music description, the first problem to solve is the inherent multidimensional representation of traditional music. In a single note, it's shape, it's position, it's color and additional marking describe height, duration and even relationship to other notes of the partition.
Especially, simultaneous notes can be written at the same position. On the other hand, code is written in a linear way, disallowing easy simultaneous note description. Taking the midi file format as an example, this problem has been solved using note events (note on and note off) with occurring time relative to the previous event.

Here, we want some more intuitive way to describe parallel and sequential patterns. Notes are described as height and durations, composed in parallel or sequentially.
It is enough to consider a melody as a set of multiple tracks played together (parallel composition of sequential notes). This is equivalent to having a sequence of chords played one after each other (sequential composition of parallel notes). However both representations are not convenient when it comes to a single voice that splits in two parts for a short time. In any case, one has to consider this small second line from the beginning until the end, almost filled with rests.
That's why in the representation of this project, both parallel and sequential segments has the ability to store any kind of segment. From this choice results melodies represented through a tree structure.


\subsection{Tree representation}
As we want a common interface for sequential and parallel segments, it is quite natural to represent them as a simple syntax tree. This is archived using the following definitions.
\begin{lstlisting}
trait MusicalSegment {
  def melody: List[MusicalSegment]
}
case class SequentialSegment(
      melody: List[MusicalSegment])
      implements MusicalSegment
case class ParallelSegment(
      melody: List[MusicalSegment])
      implements MusicalSegment
\end{lstlisting}
And last but not least, one needs a note representation to fit in parallel and sequential segments as leaves of the tree :

\begin{lstlisting}
case class Note(tone: Tone, duration: Duration)
      implements MusicalSegment {
  def melody = this :: Nil
}
\end{lstlisting}



\subsection{Tone and pitch}

While note duration is pretty straightforward to represent, heights have different ways of being implemented.
The most natural is to use the standard notes name : C, D, E, F etc. As the scale uses twelve half tones, this system can be extended to C, C$\sharp$, D, D$\sharp$ , E, F, ... This first solution is however not convincing as many operators as \lln{stepUp} are context dependent. \lln{C.stepUp} will not output the same in a C-major or F-major scale. Musically, it makes more sense to represent heights independent from the context.

That's why here, tones have been chosen. They represent the seven different steps of the scale and are denoted with roman numbers (I, II, III, IV, V, VI, VII). The octave can be specified and tones may be altered or not ($\flat$, $\sharp$, $\natural$). The choice of tones over pitches has many advantages.
For example, the same melody could be played in major mode or minor mode only changing the scale in which it is interpreted. Minor harmonic and melodic are not even harder to manage. Additionally, this hides the irregularity of steps separated by only one halftone. Using tone representation makes it trivial to implements functions like \lln{I + 1 // returns II}.

Looking into more details, this also allows to easily distinguish similar pitches as C$\sharp$ and D$\flat$. Regarding only playing melody this does not make any difference, but when computing intervals or even outputting partitions (if any) it will get more weight.


\subsection{Base operators}

With data representation defined, the support is ready to get some basic operators. As discussed before, there are two kinds of composition, \lln{+(that: MS)}\footnote{For the sake of conciseness, MusicalSegment is shorten MS} and \lln{|(that: MS)}. Each creating a new segment consisting of the callee and the argument. As those operators can be seen as additive components, multiplicative ones follows.

First the multiplication by an \lln{Integer} is defined as repeating the same melody $n$ times. Usually, each sequential operator should have it's parallel counterpart. But in this case, repeating the same melody in a parallel way is nearly idempotent (as the same thing gets played at the same time). Thus this operator returns the melody repeated $n$ times sequentially.

The next multiplicative operator is a generalization of the first one. It consists in repeating the melody, each time applying a specified transformation. As each time the melody gets transformed, it makes sense to distinguish parallel multiplication and sequential. They are denoted by \lln{*+} and \lln{*|}.
As application example, \lln{*|} can be used to express a canon from a single melody: 
\begin{lstlisting}
canon *| (_ >> someDuration) 
\end{lstlisting}
where \lln{>>} denotes a time shifting of specified duration.

\subsection{Depth control and recursion}

Because of the nature of the project (music generation) and the tree structure of the implementation, recursive methods on the trees should be available.

\subsubsection{Depth control}

The first concern about those methods is the depth of the tree previously generated. It would be convenient to have the tree structure representing the melody structure itself, as parts composed by a sequence of smaller parts for instance. But a closer look at the \lln{+} definition shows that the generated tree is will be only binary, as no component will be included in the other one.

This leads to extend the definition of \lln{+(that: MS)} into \lln{+(depth: Int, that: MS)}. The additional argument (depth) is interpreted as the suggested resulting total depth of the operator. If depth parameter is smaller than the size of one tree, then it will be adjusted to the size of that tree. Depth parameter is also not respected when combining sequential and parallel melodies as including components of a parallel segment in a sequential one will change their interpretation. 

Finally, for use case, the following alias are provided :
\lln{+ := +(1, _)}, \lln{++ := +(2, _)}, \lln{+++ := +(3, _)}, \lln{++++ := +(4, _)}
The same holds for the parallel composition.

The choice of this implementation over the standards \lln{+} and \lln{++}, where the first add the argument in the callee and the latter create a new instance holding the callee and the argument was to avoid confusions where \lln{+} have different meaning in the same expression if it comes before or after \lln{++}.

\subsubsection{Recursion}

The depth being controlled, the structure is ready to implement recursive operators on the tree.

Implemented recursive functions follow the same pattern as the previous multiplicative operators. The main idea is to specify transformations that will be applied to the structure of melody.

The simplest one, and already useful for compact transformation descriptions is the operator defined by
\begin{lstlisting}
def +>(trans: Note => MS*): MS
\end{lstlisting}
\lln{+>} takes a list of transformations and applies them one after each other to the notes of the melody. 
This then can be extended to allow more general behavior.

The first remark is that this kind of function may target not only notes but also other melody parts, responding to a given predicate. This predicate may consider composition type (parallel, sequential), tree depth or any other boolean expression on a subtree.

Then one could wish to specify more complex pattern than simple cycle when applying transformations. Then each transformation must have additional period and range parameters for application. Those concepts are combined as follow.

The generalized \lln{+>} written \lln{++>} will take a single selector and a list of transformation associated with ranges and periods. The ranges and periods are computed on the zero-based index of matching candidates for transform application.
The search is depth first search, from left to right (earlier components in melody first). When a candidate is found, the transformation is applied and the branch is considered as finished for the DFS. If no transformation match to index, given the period and range parameters, then identity is applied. If many transformation are applicable, the first one declared is applied.
% Built-in function allow transformations set declaration as follows :
% \begin{lstlisting}
% TSET := SELECT (orElse SELECT)* thenDo TRANSF (orDo TRANSF)*
% SELECT := (IsSeq | IsPar | IsNote | IsMus) ('given' PRED)*
% PRED := // a boolean function applicable to selected items
% TRANSF := // transformation applicable to selected items, with optionnal period, from and to parameters.
% \end{lstlisting}

For example, repeating all flat chord of a melody (set of notes played together) is coded with :
\begin{lstlisting}
melody ++> (IsPar given (_.height==1)
    thenDo (_ *2))
\end{lstlisting}
And if we need every three chord to be not repeated :
\begin{lstlisting}
melody ++> (IsPar given (_.height==1)
    thenDo (identity(period = 3, from = 2))
    orDo (_ *2))
\end{lstlisting}
where \lln{IsPar}, \lln{given}, \lln{thenDo} and \lln{orDo} are built-in objects and methods.

\section{Generation procedure}
This section describes the main ideas that are explored to generate melodies and musical structures in this project.

To generate music that sounds good, following some musical constraints is required. Respecting such rules can be basically archived through two ways. Describe generative formulas that will create musical components in a given language or implement a control system that will check if a given component follows the rules. Both visions are different applications of formal grammars. One as parsing algorithm (melody checking) and the other one as generating sentences in the given language.

However, it turns out to be more related to machine learning processing which goes out the scope of this project, and formal grammar implementation represent a too big step of abstraction from the previously defined language.

That's why we will try to reduce these concepts to simpler ones. First trying to generalize a concrete example into a set of generative methods depending on some parameters, then to adapt the structure of the tree to support constraints implementation on sequential, parallel and mixed patterns.
A base set of rules for implementation will be the counterpoint rules, as they are well defined concept for music composition.


\subsection{Simple melodies}

The music generation research is planned starting with simple melodies (one sequence of notes) composing a longer one.
First, a melody is abstracted in a function able to generate it, given a set of parameters. Those functions should the be able to generate different melodies following the same pattern, and ideally commutable in a bigger context. This could lead to a more complex melody build over small patterns that are defined and modulated by a set of parameters.

Finally, an interesting feature would be to have musical rules implemented as set of simple checks that avoid producing bad music. Common examples are unresolved leading tone or augmented fourth in the melody. 

\subsection{Managing more complex structures}

At this point, the tree structure used to represent melodies using parallel and sequential composition does not provide a time track of the whole melody. 'Time track' represents a way of accessing the melody linearly, indexed by the time. This "view" would allow to code more complete concepts, managing parallel dependencies as well as sequential ones.

%More options : data visualisation toolkit

\section{Conclusion}

As this presentation describe a work-in-progress, writing it enforce taking another sight over the implementations and some of them appear to be not so good as expected.

One choice that is very likely to be re-factored is the status of sequential and parallel segments as case classes. They should be turned into abstract classes to allow extending them as case classes. This would give the \lln{++>} method more precise candidate selection and provide good support to implement simple grammar language.

Depth-controlled composition operators will be also subject to reviewing. Standard implementation using only two operators was supposed confusing. But current implementation turns out to be a set of exceptions rather than a real rule. Furthermore, the code written with the standard solution may not be as non-intuitive as expected.

In any case, there is still a lot of work to do. But hopefully some basic generation features are close to be archived and this is really motivating to make the work going on.

% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.

% \acks

% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

% \bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

% \begin{thebibliography}{}
% \softraggedright

% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
% P. Q. Smith, and X. Y. Jones. ...reference text...

% \end{thebibliography}


\end{document}
